git-cc
======

Simple bridge between base Clearcase or UCM and Git.

Warning
=======

I wrote this purely for fun and to see if I could stop use Clearcase at work
once and for all.

I will probably continue to hack away at it to suite my needs, but I would
love to see it get some real-world polish. (Actually what I would love to see
more is for Clearcase to die, but don't think that's going to happen any time
soon).

Suggestions on anything I've done are more than welcome.

Also, I have made a change recently to support adding binary files which uses
git-cat. Unfortunately git-cat doesn't handle end line conversions and so I
would strongly recommended turning off core.autocrlf before importing your
history!!! Don't try changing this after your first commit either as it will
only make matters worse. My apologies to anyone that is stung by this.

Workflow
========

Initialise:

gitcc init d:/view/xyz
gitcc rebase 
# Get coffee
# Do some work
git add .
git commit -m "I don't actually drink coffee"
gitcc rebase
gitcc checkin

Other:

These are two useful flags for rebase which is use quite frequently.

gitcc rebase --stash

Runs stash before the rebase, and pops it back on afterwards.

gitcc rebase --dry-run

Prints out the list of commits and modified files that are pending in clearcase.

Configuration
=============

You need to add a mapping for each user in your clearcase history to users.py.
You can also limit which branches and folders you import from.
eg. .git/gitcc

[gitcc]
clearcase = D:\views\co4222_flex\rd_poc
include = FolderA|FolderB
branches = main|ji_dev|ji_*_dev|iteration_*_dev
debug = False

I would have put this in the .git/config file except python didn't seems to like
reading it.

Notes
=====

Can either work with static or dynamic views. I use dynamic at work because
it's much faster not having to update. I've done an update in rebase anyway,
just-in-case someone wants to use it that way.

Can also work with UCM, which requires the 'type' config to be set to 'UCM'.
This is still a work in progress as I only recently switched to this at work.
Note the the history is still retrieved via lshistory and not specifically from
any activity information. This is largely for convenience for me so I don't have
to rewrite everything. Therefore things like 'recommended' baselines are ignored.
I don't know if this will cause any major dramas or not.

Behind the scenes
=================

A smart person would have looked at other git bridge implementations for
inspiration, such as git-svn and the like. I, on the other hand, decided to go 
cowboy and re-invent the wheel. I have no idea how those other scripts do their
business and so I hope this isn't a completely stupid way of going about it.

I wanted to have it so that any point in history you could rebase on-top of the
current working directory. I've done this by using the clearcase commit time
for git as well. In addition the last rebased commit is tagged and is used
to limit the history query for any chances since. This tagged changeset is
therefore also used to select which commits need to be checked into clearcase.

Problems
========

The big problem is renames, where no content is changed. Clearcase's
lshistory doesn't tell you about renames and so I will (eventually) have to
work out what files have been added/removed and manually copy files that are not
modified. It's not that hard, but it is quite complicated for something so
uncommon, or at least for me where renames almost always require some content
change. ie Class and package name changes in Java. I had my first straight
rename today with an image. I manually amended the commit in git, which was
annoying but simple enough.

It is worth nothing that when initially importing the history from Clearcase
that renames are not kept, and in fact you don't get the original file until
the point at which it was renamed to it's _current_ name. This is quite sad
and means that the imported history is not a true one and so rolling back to
older revisions will be somewhat limited as it is likely everything won't
compile. Once you are up-to-date renames will be fine (except for the case above)
but if you reset your branch to an older changeset and rebase again you'll lose
the original file. Other Clearcase importers seem restricted by the same problem,
but none-the-less it is most frustrating. Grr!
